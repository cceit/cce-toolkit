import re

import unicodedata

from django.db.models.fields.related import RelatedField
from django.shortcuts import _get_queryset
from django.utils import six
from django.utils.encoding import force_text
from django.utils.functional import allow_lazy
from django.utils.safestring import mark_safe, SafeText
from django.template.loader import render_to_string
from django.core.mail import EmailMultiAlternatives
from django.conf import settings


def usernamify(username, special_chars='@.+-_'):
    """
    Remove characters invalid for use in a username and convert to lowercase.

    :param string username: unsanitized string
    :param string special_chars: special characters that need to be removed
     from the provided username. *Default value: '@.+-_'*

    :returns: sanitized string to be used as username

    .. note:: If username contains no valid characters, the returned value will
     be the empty string, which is not a valid username on its own.

    Author:
        Fredrick Wagner
    """
    return ''.join(c for c in username if c.isalnum() or c in special_chars)\
             .lower()


def generate_username_from_name(first_name, last_name):
    """
    Method generates a valid username based off the given first and last names.
    It ensures that the username is unique by querying the user model.
    Usernames are generated by combining the first letter of the first name and
    the full last name (fbar). If this combination already exists, a number is
    appended to the username (fbar1, fbar2) and retested until a unique
    username is found.

    :param string first_name: user first name
    :param string last_name: user last name

    :returns: unique, valid username based off the given first and last names

    :raises IndexError: if first_name is empty or contains no characters valid
     for use in a username.

    .. note:: The method will not create the user object, it will only return
     a valid username that can be used in creating a user object outside this
     method

    Usage:
        .. code-block:: python
            :linenos:

            >>> generate_username_from_name('Foo', 'Bar')
            fbar
            >>> generate_username_from_name('Foo', 'Bar')
            fbar1
            >>> generate_username_from_name('Foo', 'Bar')
            fbar2
    """
    from django.contrib.auth.models import User
    base_username = 'user'
    if first_name:
        base_username = usernamify(first_name)[0]
    if last_name:
        base_username += usernamify(last_name)

    username = base_username
    # If the username is taken, add a serial number.
    number = 1
    while User.objects.filter(username=username).exists():
        username = base_username + str(number)
        number += 1
    return username


def replace_key(old_key, new_key, dictionary):
    if old_key in dictionary:
        value = dictionary.pop(old_key)
        dictionary[new_key] = value
    return dictionary


def snakify(value):
    """
    Converts to ASCII. Converts spaces to underscores. Removes characters that
    aren't alphanumerics, underscores, or hyphens. Converts to lowercase.
    Also strips leading and trailing whitespace.

    :param string value: unsanitized value

    :returns: snakified value

    Usage:
        .. code-block:: python
            :linenos:

            >>> snakify('polls-report May 1, 2016')
            u'polls_report_may_1_2016'

    """
    value = force_text(value)
    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')\
        .decode('ascii')
    value = re.sub('[^\w\s-]', '', value).strip().lower()
    return mark_safe(re.sub('[-\s]+', '_', value))

snakify = allow_lazy(snakify, six.text_type, SafeText)


def get_object_or_none(klass, *args, **kwargs):
    """
    Method returns the queried object or None if the object does not exist

    Usage:
        .. code-block:: python
            :linenos:

            >>> get_object_or_none(Poll, pk=1)
            None
            >>> get_object_or_none(Poll, {'pk': 1, 'user': 1})
            None
            >>> get_object_or_none(Poll, {'pk': 2})
            Poll object

    """
    queryset = _get_queryset(klass)
    try:
        return queryset.get(*args, **kwargs)
    except queryset.model.DoesNotExist:
        return None


def _hasfield(model_fields, field_name):
    """
    Check if field name exists in list of model fields

    :param list model_fields: List of Django Model object fields
    :param string field_name: attribute string, dotted or dunderscored.
    example: 'user.first_name' or 'user__first_name'

    :returns: Field object or False

    """
    for field in model_fields:
        if field.name == field_name:
            return field
    return False


def hasfield(model, field_name):
    """
    Returns whether the specified field_name string is a valid field on
     model or its related models

    :param Model model: Django Model object
    :param string field_name: attribute string, dotted or dunderscored.
     example: 'user.first_name' or 'user__first_name'

    :returns: Field object or False

    Usage:
        .. code-block:: python
            :linenos:

            >>> hasfield(Poll, 'question')
            Django Model
            >>> hasfield(Poll, 'user__name')
            Django Model
            >>> hasfield(Poll, 'user.username')
            Django Model
            >>> hasfield(Poll, 'user.full_name')
            False # full_name is a property method not a field
    """
    field_name = field_name.replace('__', '.')
    model_fields = model._meta.fields
    field_names = field_name.split('.')
    fields_count = len(field_names)
    i = 0
    for field_name in field_names:
        related_field = _hasfield(model_fields, field_name)

        # if no match found or if a match found and this is the last field
        #  to lookup, return the result
        if not related_field or (related_field and i == (fields_count - 1)):
            return related_field

        # if its a ForeignKey or a ManytoManyField or a OnetoOneField, look
        # through the related model
        if isinstance(related_field, RelatedField):
            model_fields = related_field.related_model._meta.fields
        i += 1
    return False


def get_subclass_instance(obj):
    """
        Returns the utilized child class instance of a superclass instance.

        :param Model obj: Django Model instance

        :returns: Subclass instance or None
    """
    try:
        subclass_instance_name = next(
            rel_obj.name
            for rel_obj
            in obj._meta.get_all_related_objects()
            if rel_obj.parent_link and hasattr(obj, rel_obj.name)
        )
    except StopIteration:
        return None
    return getattr(obj, subclass_instance_name)


def send_template_email(address_list, template_name, template_context=None, context=None, subject="NO SUBJECT",
                        attachments=None, from_address=None):
    email_context = {}
    if template_context:
        email_context.update(template_context)
    msg = render_to_string(template_name, email_context, context)
    email_msg = EmailMultiAlternatives(subject, msg, from_address or settings.DEFAULT_FROM_EMAIL, address_list)
    email_msg.attach_alternative(msg, "text/html")
    if attachments is not None:
        for tupple in attachments:
            if len(tupple) == 2:
                email_msg.attach(tupple[0], tupple[1])
            else:
                email_msg.attach(tupple[0], tupple[1], tupple[2])
    email_msg.send()


def get_dict(instance, exclude_parent=False, exclude_field=None, exclude_class=None):
    """
    Generates a nested dictionary of field names and their values as key-value pairs. The dictionary is typically
    nested when dealing with many_to_many fields.
    :param instance: The object which needs to be converted to a dict.
    :param exclude_parent: Boolean indicator. True: Parents will be excluded Useful if you don't want to include
    fields of the model that is inherited by 'instance'.
    :param exclude_field: list() of fields that will be excluded.
    :param exclude_class: list() of classes that will be excluded from the dictionary. If the dictionary doesn't
    need a particular foreign key (i.e. another model), pass that model's class here and it won't be included in the
    final dictionary.
    :return: dict() representation of the instance.
    """
    current_state = dict()
    instance_fields = set(field for field in instance._meta.get_fields())
    instance_class = instance.__class__

    # Remove parent's fields from instance_fields.
    if exclude_parent:
        for parent in instance.__class__.__bases__:
            instance_fields = instance_fields - set(field for field in parent._meta.get_fields())

    # Filter instance_fields by removing classes in exclude.
    if exclude_class:
        instance_fields = instance_fields - set(field for field in instance_fields
                                                if field.related_model in exclude_class)

    # Filter instance field by removing fields in exclude
    if exclude_field:
        instance_fields = instance_fields - set(field for field in instance_fields
                                                if field.name in exclude_field)

    # Generate the dictionary by iterating through the fields.
    for field in instance_fields:

        # Many-To-Many Fields, ignore the change model associated with the current model.
        if field.one_to_many and 'change' not in field.name:

            # Check if there is a related name:
            mgr = getattr(instance, field.get_accessor_name())

            # We will save all the objects as a dictionary.
            mgr_dict = dict()
            for idx, obj in enumerate(mgr.all()):
                _id = field.get_accessor_name() + '_' + str(idx)
                mgr_dict[_id] = get_dict(obj,
                                         exclude_parent=exclude_parent,
                                         exclude_class=[instance_class])

            current_state[field.get_accessor_name() + 's'] = mgr_dict

        # Foreign keys.
        elif field.many_to_one:  # Foreign key.
            # get the string representation of the obj.
            current_state[field.name] = str(getattr(instance, field.name))

        # Other keys that don' have relationships
        elif not field.auto_created and not field.many_to_many:
            if field.choices:
                current_state[field.name] = instance._get_FIELD_display(field)
            else:
                current_state[field.name] = getattr(instance, field.name)

    return current_state


def get_flat_dict(instance, exclude_parent=False, exclude_field=None, exclude_class=None):
    """
    Generates a flat dictionary of field names and their values as key-value pairs.
    :param instance: The object which needs to be converted to a dict.
    :param exclude_parent: Boolean indicator. True: Parents will be excluded Useful if you don't want to include
    fields of the model that is inherited by 'instance'.
    :param exclude_field: list() of fields that will be excluded.
    :param exclude_class: list() of classes that will be excluded from the dictionary. If the dictionary doesn't
    need a particular foreign key (i.e. another model), pass that model's class here and it won't be included in the
    final dictionary.
    :return: dict() representation of the instance.
    """
    current_state = dict()
    instance_fields = set(field for field in instance._meta.get_fields())
    instance_class = instance.__class__

    # Remove parent's fields from instance_fields.
    if exclude_parent:
        for parent in instance.__class__.__bases__:
            instance_fields = instance_fields - set(field for field in parent._meta.get_fields())

    # Filter instance_fields by removing classes in exclude.
    if exclude_class:
        instance_fields = instance_fields - set(field for field in instance_fields
                                                if field.related_model in exclude_class)

    # Filter instance field by removing fields in exclude
    if exclude_field:
        instance_fields = instance_fields - set(field for field in instance_fields
                                                if field.name in exclude_field)

    # Generate the dictionary by iterating through the fields.
    for field in instance_fields:

        # Many-To-Many Fields, ignore the change model associated with the current model.
        if field.one_to_many and 'change' not in field.name:

            # Check if there is a related name:
            mgr = getattr(instance, field.get_accessor_name())

            # We will save all the objects as a dictionary.
            mgr_dict = dict()
            for idx, obj in enumerate(mgr.all()):
                obj_dict = get_dict(obj, exclude_parent=exclude_parent, exclude_class=[instance_class])
                for key in obj_dict.keys():
                    new_key = str(key) + '_' + str(idx)
                    current_state[new_key] = obj_dict[key]

        # Foreign keys.
        elif field.many_to_one:  # Foreign key.
            # get the string representation of the obj.
            current_state[field.name] = str(getattr(instance, field.name))

        # Other keys that don' have relationships
        elif not field.auto_created and not field.many_to_many:
            if field.choices:
                current_state[field.name] = instance._get_FIELD_display(field)
            else:
                current_state[field.name] = getattr(instance, field.name)

    return current_state


def get_state_diff(old_state, new_state):
    """
    Calculates the change between two object states.
    :param old_state: The old state of the object.
    :param new_state: The new state of the object.
    :return: Dictionary of the fields changed as keys and corresponding "previous" and "current" state as value of key.
    """
    change = dict()
    old_keys = set(old_state.keys())
    new_keys = set(new_state.keys())
    removed_keys = old_keys - new_keys
    added_keys = new_keys - old_keys
    intersect_keys = new_keys & old_keys
    for key in removed_keys:
        if isinstance(old_state[key], dict) and old_state[key]:
            change[key] = get_state_diff(old_state[key], dict())
        else:
            change[key] = {'previous': old_state[key], 'current': 'NA'}
    for key in added_keys:
        if isinstance(new_state[key], dict) and new_state[key]:
            change[key] = get_state_diff(dict(), new_state[key])
        elif new_state[key]:
            if str(new_state[key]).lower() != "none":
                change[key] = {'previous': 'NA', 'current': new_state[key]}
    for key in intersect_keys:
        if (isinstance(old_state[key], dict) and old_state[key]) \
                or (isinstance(new_state[key], dict) and new_state[key]):
            _change = get_state_diff(old_state[key], new_state[key])
            if _change:
                change[key] = _change
        else:
            if new_state[key] != old_state[key]:
                if new_state[key]:
                    current = 'NA' if str(new_state[key]).lower() == 'none' else new_state[key]
                else:
                    current = 'NA'
                if not old_state[key]:
                    previous = 'NA'
                else:
                    previous = 'NA' if str(old_state[key]).lower() == 'none' else old_state[key]
                change[key] = {'previous': previous, 'current': current}
    return change
