import re

import unicodedata
from difflib import SequenceMatcher

from django.db.models.fields.related import RelatedField
from django.shortcuts import _get_queryset
from django.utils import six
from django.utils.encoding import force_text
from django.utils.functional import allow_lazy
from django.utils.safestring import mark_safe, SafeText
from django.template.loader import render_to_string
from django.core.mail import EmailMultiAlternatives
from django.conf import settings


def usernamify(username, special_chars='@.+-_'):
    """
    Remove characters invalid for use in a username and convert to lowercase.

    :param string username: unsanitized string
    :param string special_chars: special characters that need to be removed
     from the provided username. *Default value: '@.+-_'*

    :returns: sanitized string to be used as username

    .. note:: If username contains no valid characters, the returned value will
     be the empty string, which is not a valid username on its own.

    Author:
        Fredrick Wagner
    """
    return ''.join(c for c in username if c.isalnum() or c in special_chars)\
             .lower()


def generate_username_from_name(first_name, last_name):
    """
    Method generates a valid username based off the given first and last names.
    It ensures that the username is unique by querying the user model.
    Usernames are generated by combining the first letter of the first name and
    the full last name (fbar). If this combination already exists, a number is
    appended to the username (fbar1, fbar2) and retested until a unique
    username is found.

    :param string first_name: user first name
    :param string last_name: user last name

    :returns: unique, valid username based off the given first and last names

    :raises IndexError: if first_name is empty or contains no characters valid
     for use in a username.

    .. note:: The method will not create the user object, it will only return
     a valid username that can be used in creating a user object outside this
     method

    Usage:
        .. code-block:: python
            :linenos:

            >>> generate_username_from_name('Foo', 'Bar')
            fbar
            >>> generate_username_from_name('Foo', 'Bar')
            fbar1
            >>> generate_username_from_name('Foo', 'Bar')
            fbar2
    """
    from django.contrib.auth.models import User
    base_username = 'user'
    if first_name:
        base_username = usernamify(first_name)[0]
    if last_name:
        base_username += usernamify(last_name)

    username = base_username
    # If the username is taken, add a serial number.
    number = 1
    while User.objects.filter(username=username).exists():
        username = base_username + str(number)
        number += 1
    return username


def replace_key(old_key, new_key, dictionary):
    if old_key in dictionary:
        value = dictionary.pop(old_key)
        dictionary[new_key] = value
    return dictionary


def snakify(value):
    """
    Converts to ASCII. Converts spaces to underscores. Removes characters that
    aren't alphanumerics, underscores, or hyphens. Converts to lowercase.
    Also strips leading and trailing whitespace.

    :param string value: unsanitized value

    :returns: snakified value

    Usage:
        .. code-block:: python
            :linenos:

            >>> snakify('polls-report May 1, 2016')
            u'polls_report_may_1_2016'

    """
    value = force_text(value)
    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')\
        .decode('ascii')
    value = re.sub('[^\w\s-]', '', value).strip().lower()
    return mark_safe(re.sub('[-\s]+', '_', value))

snakify = allow_lazy(snakify, six.text_type, SafeText)


def get_object_or_none(klass, *args, **kwargs):
    """
    Method returns the queried object or None if the object does not exist

    Usage:
        .. code-block:: python
            :linenos:

            >>> get_object_or_none(Poll, pk=1)
            None
            >>> get_object_or_none(Poll, {'pk': 1, 'user': 1})
            None
            >>> get_object_or_none(Poll, {'pk': 2})
            Poll object

    """
    queryset = _get_queryset(klass)
    try:
        return queryset.get(*args, **kwargs)
    except queryset.model.DoesNotExist:
        return None


def _hasfield(model_fields, field_name):
    """
    Check if field name exists in list of model fields

    :param list model_fields: List of Django Model object fields
    :param string field_name: attribute string, dotted or dunderscored.
    example: 'user.first_name' or 'user__first_name'

    :returns: Field object or False

    """
    for field in model_fields:
        if field.name == field_name:
            return field
    return False


def hasfield(model, field_name):
    """
    Returns whether the specified field_name string is a valid field on
     model or its related models

    :param Model model: Django Model object
    :param string field_name: attribute string, dotted or dunderscored.
     example: 'user.first_name' or 'user__first_name'

    :returns: Field object or False

    Usage:
        .. code-block:: python
            :linenos:

            >>> hasfield(Poll, 'question')
            Django Model
            >>> hasfield(Poll, 'user__name')
            Django Model
            >>> hasfield(Poll, 'user.username')
            Django Model
            >>> hasfield(Poll, 'user.full_name')
            False # full_name is a property method not a field
    """
    field_name = field_name.replace('__', '.')
    model_fields = model._meta.fields
    field_names = field_name.split('.')
    fields_count = len(field_names)
    i = 0
    for field_name in field_names:
        related_field = _hasfield(model_fields, field_name)

        # if no match found or if a match found and this is the last field
        #  to lookup, return the result
        if not related_field or (related_field and i == (fields_count - 1)):
            return related_field

        # if its a ForeignKey or a ManytoManyField or a OnetoOneField, look
        # through the related model
        if isinstance(related_field, RelatedField):
            model_fields = related_field.related_model._meta.fields
        i += 1
    return False


def get_subclass_instance(obj):
    """
        Returns the utilized child class instance of a superclass instance.

        :param Model obj: Django Model instance

        :returns: Subclass instance or None
    """
    try:
        subclass_instance_name = next(
            rel_obj.name
            for rel_obj
            in obj._meta.get_all_related_objects()
            if rel_obj.parent_link and hasattr(obj, rel_obj.name)
        )
    except StopIteration:
        return None
    return getattr(obj, subclass_instance_name)


def send_template_email(address_list, template_name, template_context=None, context=None, subject="NO SUBJECT",
                        attachments=None, from_address=None):
    email_context = {}
    if template_context:
        email_context.update(template_context)
    msg = render_to_string(template_name, email_context, context)
    email_msg = EmailMultiAlternatives(subject, msg, from_address or settings.DEFAULT_FROM_EMAIL, address_list)
    email_msg.attach_alternative(msg, "text/html")
    if attachments is not None:
        for tupple in attachments:
            if len(tupple) == 2:
                email_msg.attach(tupple[0], tupple[1])
            else:
                email_msg.attach(tupple[0], tupple[1], tupple[2])
    email_msg.send()


def find_closest_match(val, list_to_compare, similarity=0.8):
    """
    Takes a SequenceMatcher object, sets its seq2 object to val, compares it against items in list_to_compare
    and returns the item which is a high probability of match (ratio > 0.8). Note that it requires val as a string
    and the list should also be a list of strings.
    :param val: The value to compare.
    :param list_to_compare: The list of items to compare 'val' with.
    :param similarity: How similar the value in list_to_compare should be to val
    on a scale of 0 to 1 (default = 0.8)
    :return: index of the item in list_to_compare that most closely matches with 'val'
    """
    seq_matcher = SequenceMatcher()
    seq_matcher.set_seq2(val.lower())
    for idx, list_item in enumerate(list_to_compare):
        seq_matcher.set_seq1(list_item.lower())
        ratio = seq_matcher.ratio()
        if ratio >= similarity:
            return idx
    return None
